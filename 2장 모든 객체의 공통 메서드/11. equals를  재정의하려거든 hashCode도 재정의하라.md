# Summary
- 논리적 동치성을 보이는 인스턴스라면(equals를 만족한다면), 같은 hashCode값을 가져야한다. 그렇지 않다면 hash자료구조를 사용하는데 있어 오류가 발생할 수 있다.
- equals를 재정의한다는 행위는 특정한 값을 기준으로 객체 인스턴스들을 구분한다는 뜻이다.
- 그런데, hashCode를 재정의하지 않는다면 같은 값을 지녀도 서로 다른 hashCode를 가져 같은 인스턴스로 판단하지 않을 수 있다.
- 따라서, equals를 재정의하고자 한다면, 반드시 hashCode도 함께 정의하여야 한다.
  - IDE에서 왜 equals와 hashCode를 한데 묶어놓았는지를 생각해보면 이해가 쉽다.

### hashCode와 equals 간의 기본적인 규약
- equals 비교에 사용되는 정보가 변경되지 않았다면, 런타임 동안 해당 객체의 hashCode는 여러 번 호출해도 같은 값이여야 한다.
- equals를 만족하는 두 객체는 같은 hashCode값을 가져야 한다.
- euqals를 만족하지 않는 객체들이라고 해서 반드시 다른 hashCode값을 가질 필요는 없다. 그러나 다른 값을 가지는 것이 해시테이블의 성능을 더 좋게 만든다.

### hashCode를 재정의하는 방법
#### 하나의 값만 반환하게 하기
```cs
  @Override
  public int hashCode() {
   return 1;
  }
```
- 이는 적법한 방법이기는 하나, 해시테이블의 이점을 전혀 살리지 못하게 하는 방법이다. 따라서 절대 이런 방식으로는 구현하지 말자.
  - 모든 객체의 해시 값이 같다면, 하나의 버켓에 모든 객체가 담기게 될 것이다. 

#### 직접 구현하기
- hashCode를 직접 구현하는 공식도 있고, 이를 사용해서 구현한 hashCode()는 준수한 성능을 보이지만 굳이 알 필요는 없다.
  - 성능도 뒤쳐지지 않고 더 사용하기 간편한 방법이 있다.
  - 직접 구현 하기 위한 공식도 있다는 사실 정도만 알아두자.

#### Object.hash 사용하기
```cs
  @Override
  public int hashCode() {
   return Objects.hash(arg, arg, arg ...);
  }
```
- Objects 클래스의 정적 메서드인 hash를 사용하면 한 줄만으로 hashCode를 재정의 할 수 있다. hash함수에 인자로 핵심 값들을 전부 넣어주기만 하면 된다.
- 그러나 해당 방법은 성능적인 측면에서 불리함을 지닌다.
  - 기본적으로 입력된 인자들을 담기 위한 배열을 만들어야 한다.
  - 인자 중에 기본 타입이 있다면 박싱, 언박싱 과정도 거쳐야 한다.

#### API 또는 IDE의 기능 이용하기
- 앞서도 언급했다 싶이, IDE에서는 기본적으로 equals와 hashCode를 재정의해주는 기능을 제공한다. 섬세하게 직접 짠 hashCode에 비해 성능은 떨어지지만 적어도 값을 빼먹는 실수는 하지 않는다.
  - IDE에서 제공하는 hashCode는 Object.hash를 사용한다.
- 구글에서 제공하는 AutoValue 프레임워크는 성능적으로도 훌륭한 equals와 hashCode를 제공해준다.
  - 의존성을 추가한 뒤, 클래스에 @AutoValue태그만 붙이면 된다! 

### hashCode를 재정의할 시 주의할 점
- 클래스가 불변이고, 해시코드를 계산하는 비용이 크다면 캐싱 방식을 고려하자.
  - static한 해시코드 값을 만들어놓고, 이를 사용하면 해시코드를 매번 새롭게 계산할 필요가 없다.
- 성능을 위해 핵심 필드를 빼놓고 해시코드를 계산하지 말자.
  - 결국 hashCode를 재정의 하는 이유는 `논리적 동치성을 만족하는 객체는 같은 객체다` 를 보장하기 위해서이다. 
  - 그런데, 논리적 동치성을 만족하기 위한 필수 조건인 핵심 필드값이 빠진다면 해시코드를 계산할 필요 자체가 없어진다.

- hashCode()가 반환하는 값의 생성 규칙을 자세히 공표하지 말자.
  - 이는 클라이언트가 해시값에 의존하게 하고, 추후에 더 나은 해시 함수를 발견해도 수정하기 어렵게 한다.
